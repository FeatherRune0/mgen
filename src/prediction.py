import pickle
import numpy
from music21 import instrument, note, stream, chord
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import LSTM
from keras.layers import BatchNormalization as BatchNorm
from keras.layers import Activation

class Prediction:
    def __init__(self, notes, pitch_names, num_pitches):
        self.notes = notes
        self.pitch_names = pitch_names
        self.num_pitches = num_pitches

    def generate_notes(self, model, nn_input, num_notes):
        """ Generate notes from the neural network based on a sequence of notes """
        # pick a random sequence from the input as a starting point
        start = numpy.random.randint(0, len(nn_input) - 1)
        int_to_note = dict((number, note) for number, note in enumerate(self.pitch_names))

        # start with the random input
        pattern = nn_input[start]
        prediction_output = []

        # generate notes
        for note_index in range(num_notes):
            prediction_input = numpy.reshape(pattern, (1, len(pattern), 1))
            prediction_input = prediction_input / float(self.num_pitches)

            prediction = model.predict(prediction_input, verbose=0)
            
            # index of the max predicted note
            index = numpy.argmax(prediction)
            result = int_to_note[index]
            prediction_output.append(result)

            pattern.append(index)
            pattern = pattern[1:len(pattern)]

        return prediction_output

    def generate_midi(self, prediction_output, path):
        """ convert the output from the prediction to notes and create a midi file
            from the notes """
        offset = 0
        output_notes = []

        # create note and chord objects based on the values generated by the model
        for pattern in prediction_output:
            # pattern is a chord
            if ('.' in pattern) or pattern.isdigit():
                notes_in_chord = pattern.split('.')
                notes = []
                for current_note in notes_in_chord:
                    new_note = note.Note(int(current_note))
                    new_note.storedInstrument = instrument.Piano()
                    notes.append(new_note)
                new_chord = chord.Chord(notes)
                new_chord.offset = offset
                output_notes.append(new_chord)
            # pattern is a note
            else:
                new_note = note.Note(pattern)
                new_note.offset = offset
                new_note.storedInstrument = instrument.Piano()
                output_notes.append(new_note)

            # increase offset each iteration so that notes do not stack
            offset += 0.5

        midi_stream = stream.Stream(output_notes)

        midi_stream.write('midi', fp=path)